1. 	Додавання і видалення нод із кластера (в даному контексті cluster == replica set)
	відбувається вручну. Всі ноди пінгують одна одну і коли одна із нод вирубається всі
	інші з усих сил стараються відновити контакт із нею (можна бачить по логам, в яких 
	живі ноди пишуть шо вони намагались встановить з'єднання, але спроба зафейлилась).
	Коли нода піднімається інші це зразу помічають, встановлюють з'єднання і робота кластера
	продовжується як ні в чому не бувало.
	Якшо упавша нода була лідером (primary), то ті хто лишились перевибирають нового і 
	продовжують працювать як описано вище. Коли така нода піднімається, то вона повертається
	у кластер як secondary.

	Цікаво, що коли якась нода лишається у кластері одна (не факт шо саме одна, можливо треба
	аби кількість живих нод опустилась нижче певного порога, половини наприклад (кворума)), то
	вона не назначає себе PRIMARY, а лишається SECONDARY і тільки після відновлення ше якоїсь ноди
	відбуваються вибори.
	
2.	Драйвер, судячи з усього, і в свою чергу встановлює з'єднання із кожною нодою і обмінюється
	хартбітами (оце не факт, може просто тримає сокет відкритий і слідкує аби він раптом не закрився).
	Коли нода падає/піднімається, то драйвер помічає все це сам (знову ж таки, судячи зі спостережень,
	але це має сенс, оскільки структура кластера автоматично не змінюється і знаючи конфігурацію
	кластера у певний момент драйвер може автономно слідкувати за його станом і станом нод).
	Операція може зафейлиться, якшо вона була відправлена саме на ту ноду, яка упала.
	Під час експериментів (повторне читання кожні 2 секунди, secondaryPreferred) було помічено
	тільки одну упавшу операцію, наступна пройшла успішно.

	Сервер представлено у драйвері об'єктом com.mongodb.connection.ServerDescription. Вибір доступних нод
	виконується у методі com.mongodb.ReadPreference#choose. Спочатку ноди відбираються за типом (primary/secondary)
	за допомогою відповідного методу у ServerDescription. Так от, методи ці реалізовані наступним чином:

	public boolean isPrimary() {
        return ok && (type == REPLICA_SET_PRIMARY || type == SHARD_ROUTER || type == STANDALONE);
    }

    public boolean isSecondary() {
        return ok && (type == REPLICA_SET_SECONDARY || type == SHARD_ROUTER || type == STANDALONE);
    }

    і справа вся в тому, що якщо нода не пінгується (відпала), то type у неї буде UNKNOWN і таким чином вона
    не буде вважатись нід primary ні secondary і у будь-якому випадку не потрапить у список доступних для вибору
    для проведення поточної операції.

    Оновлення списку серверів проходить у com.mongodb.connection.DefaultServerMonitor.

3.  MongoHealthIndicator із Спрінга ігнорує встановлений ReadPreference, замінюючи його на primary. Якшо це неприпустимо,
    то треба вирубить його через management.health.defaults.enabled = false.
    Але!, команду, яку намагається виконати дефолтний хелсчек (buildInfo) сам драйвер монги вважає за необхідне виконувати
    на primary ноді. Тому будь-який інший ReadPreference просто ігнорується.